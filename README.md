## sort_stack_and_queue
В работе представлены решения нескольких часто встречаемых задач, таких как реализация различных типов сортировок массивов, реализация стека и очереди на основе list, различные способы вычисления факториала и n-ного члена последовательности Фибоначчи. Так же представлены решения подобных задач на платформах LeetCode и Hackerrank.

## Сортировки
*   **bubble sort** - самая простая, но одна из наименее эффективных сортировок. Основана на циклическом прохождении массива, сравнении двух стоящих рядом элементов и перестановке их, в случае, если `i+1` элемент меньше `i`.
*   **bucket sort** - основана на разбиении массива на более мелкие "корзины", сортировке их по отдельности (часто с помощью другого алгоритма) и последующем склеивании в единый массив. В данной работе использует собственную описанную ранее функцию bubble sort.
*   **counting sort** - перезаписывает элементы от минимального к максимальному в словарь, после чего проходится по нему, перебирая все целые числа от минимального до максимального, записывая в список встречающиеся в словаре элементы. Эффективна для данных с небольшим диапазоном целых значений.
*   **heap sort** - создает "кучу" с максимальным элементом в корне. Этот максимальный элемент перемещается в конец массива, а куча перестраивается для оставшихся элементов.
*   **quick sort** -  использует стратегию "разделяй и властвуй". Алгорит выбирает из массива опорный элемент (часто случайным образом), а затем перераспределяет элементы так, чтобы слева от опорного оказались элементы меньше него, а справа - больше. Алгоритм применяется рекурсивно к двум полученным подмассивам (слева и справа от опорного элемента). В общем случае - один из самых эффективных алгоритмов, однако при неудачном выборе опорного элемента сложность может оказаться O(n²).
*   **radix sort** -  не сравнительная сортировка, которая обрабатывает цифры чисел или символы строк, начиная с младшего или старшего разряда, и многократно сортируя элементы по одному разряду.

## Stack
Класс Stack представляет собой структуру данных типа "стек", реализованную на основе list. Стек реализован по принципу LIFO - последний пришел - первый ушел.

## Методы класса
*   **`push(self, x: float) -> None`** - добавляет элемент в конец стека. 
*   **`pop(self) -> float | str`** - удаляет последний элемент стека, возвращая его значение, или выводит сообщение `Stack is empty`, если стек пуст.
*   **`is_empty(self) -> bool`** - выводит `True`, если стек пуст, и `False` в обратном случае.
*   **`peek(self) -> float | str`** - возвращает значение последнего элемента стека, или выводит сообщение `Stack is empty`, если стек пуст.
*   **`__len__(self) -> int`** - возвращает количество элементов, содержащихся в стеке.
*   **`min(self) -> float`** - возвращает минимальный элемент стека, или выводит сообщение `Stack is empty`, если стек пуст.
    * Сложность: O(1)
*   **`max(self) -> float`** - возвращает максимальный элемент стека, или выводит сообщение `Stack is empty`, если стек пуст.
    * Сложность: O(1)
*   **`str(self) -> list[float]`** - возвращает стек целиком.

## Особенности реализации:
*   Поддерживает обработку специального случая -0 (конвертирует в 0).
*   Включает проверки ошибок с user-friendly выводом для всех операций.
*   Все операции сопровождаются выводом информации для пользователя.
*   Для быстрого доступа к min/max элементам используется дополнительный отсортированный список.

## Queue
Класс Queue представляет собой структуру данных типа "очередь", реализованную на основе list. Стек реализован по принципу FIFO - первый пришел - первый ушел.

## Методы класса
*   **`enqueue(self, x: float) -> None`** - добавляет элемент в начало очереди. 
*   **`dequeue(self) -> float | str`** - удаляет первый элемент очереди, возвращая его значение, или выводит сообщение `queue is empty`, если стек пуст.
*   **`is_empty(self) -> bool`** - выводит `True`, если очередь пуста, и `False` в обратном случае.
*   **`front(self) -> float | str`** - возвращает значение первого элемента очереди, или выводит сообщение `queue is empty`, если очередь пуста.
*   **`__len__(self) -> int`** - возвращает количество элементов, содержащихся в очереди.
*   **`min(self) -> float`** - возвращает минимальный элемент очереди, или выводит сообщение `queue is empty`, если очередь пуста.
    * Сложность: O(1)
*   **`max(self) -> float`** - возвращает максимальный элемент очереди, или выводит сообщение `queue is empty`, если очередь пуста.
    * Сложность: O(1)
*   **`str(self) -> list[float]`** - возвращает очередь целиком.

## Особенности реализации:
*   Поддерживает обработку специального случая -0 (конвертирует в 0).
*   Включает проверки ошибок с user-friendly выводом для всех операций.
*   Все операции сопровождаются выводом информации для пользователя.
*   Для быстрого доступа к min/max элементам используется дополнительный отсортированный список.

## Установка
```bash
git clone https://github.com/ZhenyaHeisenberg/sort_stack_and_queue
```

## Примеры использования

### Стек
```txt
push 5
push 1.8
peek
min
max
pop
str
len
```

### Очередь
```txt
enqueue 5
enqueue 1.8
front
min
max
dequeue
str
len
```

## Тестирование
```bash
# Находясь в корне проекта
python -m pytest --cov=src --cov-report=term-missing
```
