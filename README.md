## sort_stack_and_queue
В работе представлены решения нескольких часто встречаемых задач, таких как реализация различных типов сортировок массивов, реализация стека и очереди на основе list, различные способы вычисления факториала и n-ного члена последовательности Фибоначчи. Так же представлены решения сопряженных задач на платформах LeetCode и Hackerrank.

## Сортировки
*   **bubble sort** - самая простая, но одна из наименее эффективных сортировок. Основана на циклическом прохожднии массива, сравнении двух стоящих рядом элеменов и перестановке их, в случае, если `i+1` элемент меньше `i`.
*   **bucket sort** - основана на разбиении массива на более мелкие "корзины", сортировке их по отдельности (часто с помощью другого алгоритма) и последующем склеивании в единый массив. В данной работе использует собственную описанную ранее функцию bubble sort.
*   **counting sort** - перезаписывает элементы от минимального к максимальному в словарь, после чего проходится по нему, перебирая все целые числа от минимального до максимального, записывая в список встречающиеся в словаре элементы. Эффективна для данных с небольшим диапазоном целых значений.
*   **heap sort** - создает "кучу" с максимальным элементом в корне. "тот максимальный элемент перемещается в конец массива, а куча перестраивается для оставшихся элементов.
*   **quick sort** -  использует стратегию "разделяй и властвуй". Алгорит выбирает из массива опорный элемент (часто случайным образом), а затем перераспределяет элементы так, чтобы слева от опорного оказались элементы меньше него, а справа - больше. Алоритм применяется рекусривно к двум полученным подмассивам (слева и справа от опорного элемента). В общем случае - один из самых эффективных алгоритмов, однако при неудачом выборе опорного элемента сложность может оказаться O(n²).
*   **radix sort** -  не сравнительная сортировка, которая обрабатывает цифры чисел или символы строк, начиная с младшего или старшего разряда, и многократно сортируя элементы по одному разряду.
