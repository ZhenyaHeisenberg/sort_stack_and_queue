## sort_stack_and_queue
В работе представлены решения нескольких часто встречаемых задач, таких как реализация различных типов сортировок массивов, реализация стека и очереди на основе list, различные способы вычисления факториала и n-ного члена последовательности Фибоначчи. Так же представлены решения сопряженных задач на платформах LeetCode и Hackerrank.

## Сортировки
*   **bubble sort** - самая простая, но одна из наименее эффективных сортировок. Основана на циклическом прохожднии массива, сравнении двух стоящих рядом элеменов и перестановке их, в случае, если `i+1` элемент меньше `i`.
*   **bucket sort** - основана на разбиении массива на более мелкие "корзины", сортировке их по отдельности (часто с помощью другого алгоритма) и последующем склеивании в единый массив. В данной работе использует собственную описанную ранее функцию bubble sort.
*   **counting sort** - перезаписывает элементы от минимального к максимальному в словарь, после чего проходится по нему, перебирая все целые числа от минимального до максимального, записывая в список встречающиеся в словаре элементы. Эффективна для данных с небольшим диапазоном целых значений.
*   **heap sort** - создает "кучу" с максимальным элементом в корне. "тот максимальный элемент перемещается в конец массива, а куча перестраивается для оставшихся элементов.
*   **quick sort** -  использует стратегию "разделяй и властвуй". Алгорит выбирает из массива опорный элемент (часто случайным образом), а затем перераспределяет элементы так, чтобы слева от опорного оказались элементы меньше него, а справа - больше. Алоритм применяется рекусривно к двум полученным подмассивам (слева и справа от опорного элемента). В общем случае - один из самых эффективных алгоритмов, однако при неудачом выборе опорного элемента сложность может оказаться O(n²).
*   **radix sort** -  не сравнительная сортировка, которая обрабатывает цифры чисел или символы строк, начиная с младшего или старшего разряда, и многократно сортируя элементы по одному разряду.

## Stack
Класс Stack представляет собой структуру данных типа "стек", реализованную на основе list. Стек реализован по принципу LIFO - последний пришел - первый ушел.

## Методы класса
*   **`push(self, x: float) -> None`** - добавляет элемент в конец стека. 
*   **`pop(self) -> float | str`** - удаляет последний элемент стека, возвращая его значение, или выводит сообщение `Stack is empty`, если стек пуст.
*   **`is_empty(self) -> bool`** - выводит `True`, если стек пуст, и `False` в обратном случае.
*   **`peek(self) -> float | str`** - возвращает значение посленего элемента стека, или выводит сообщение `Stack is empty`, если стек пуст.
*   **`__len__(self) -> int`** - возвращает количетво элементов, содержащихся в стеке.
*   **`min(self) -> float`** - возвращает минимальный элемент стека, или выводит сообщение `Stack is empty`, если стек пуст.
    * Сложность: O(1)
*   **`max(self) -> float`** - возвращает максимальный элемент стека, или выводит сообщение `Stack is empty`, если стек пуст.
    * Сложность: O(1)
*   **`str(self) -> list[float]`** - возвращает стек целиком.